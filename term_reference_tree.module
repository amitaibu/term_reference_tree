<?php
// $id$

/**
 * Implements hook_field_widget_info().
 */
function term_reference_tree_field_widget_info() {
  return array(
    'term_reference_tree' => array (
      'label' => 'Term reference tree',
      'field types' => array('taxonomy_term_reference'),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM, 
        'default value' => FIELD_BEHAVIOR_DEFAULT,
      ),
      'settings' => array(
        'start_minimized' => 0,
        'leaves_only' => 0,
      ),
    ),
  );
}

/**
 * Implements hook_field_widget_settings_form().
 */
function term_reference_tree_field_widget_settings_form($field, $instance) {
  $widget = $instance['widget'];
  $settings = $widget['settings'];
  $form = array();
  
  if($widget['type'] == 'term_reference_tree') {
    $form['start_minimized'] = array(
      '#type' => 'checkbox',
      '#title' => t('Start minimized'),
      '#description' => t('Make the tree appear minimized on the form by default'),
      '#default_value' => $settings['start_minimized'],
      '#return_value' => 1,
    );
    
    $form['leaves_only'] = array(
      '#type' => 'checkbox',
      '#title' => t('Leaves only'),
      '#description' => t("Don't allow the user to select items that have children"),
      '#default_value' => $settings['leaves_only'],
      '#return_value' => 1,
    );
  }
  
  return $form;
}

/**
 * Implements hook_element_info().
 */
function term_reference_tree_element_info() {
  $types = array(
    'checkbox_tree' => array(
      '#input' => true,
      '#process' => array('term_reference_tree_process_checkbox_tree'),
      #'#element_validate' => array('term_reference_tree_checkbox_tree_validate'),
      '#theme' => array('checkbox_tree'),
      #'#theme_wrappers' => array('form_element'),
      '#pre_render' => array('form_pre_render_conditional_form_element'),
    ),
    'radio_tree' => array(
      '#input' => true,
      '#process' => array('term_reference_tree_process_radio_tree'),
      #'#element_validate' => array('term_reference_tree_radio_tree_validate'),
      '#theme' => array('radio_tree'),
      #'#theme_wrappers' => array('form_element'),
      '#pre_render' => array('form_pre_render_conditional_form_element'),
    ),    
  );
  
  return $types;
}

/**
 * Implements hook_theme().
 */
function term_reference_tree_theme() {
  #dsm('term_reference_tree_theme');
  return array(
    'checkbox_tree' => array(
      'render element' => 'element',
    ),
    'radio_tree' => array (
      'render element' => 'element',
    ),
  );
}

/**
 * Process the checkbox_tree widget.
 * 
 * This function processes the checkbox_tree widget.  At this point it just calls
 * the generalized drawing function that draws both the checkbox_tree and radio_tree
 * widgets.
 * 
 * @param $element
 *   The element to be drawn.
 * @param $form_state
 *   The form state.
 * 
 * @return
 *   The processed element.
 */
function term_reference_tree_process_checkbox_tree($element, $form_state) {
  $element = _term_reference_tree_render($element, $form_state);
  #dsm($element, 'term_reference_tree_process_checkbox_tree');
  return $element;
}

/**
 * Process the radio_tree widget.
 * 
 * This function processes the radio_tree widget.  At this point it just calls
 * the generalized drawing function that draws both the checkbox_tree and radio_tree
 * widgets.
 * 
 * @param $element
 *   The element to be drawn.
 * @param $form_state
 *   The form state.
 * 
 * @return
 *   The processed element.
 */
function term_reference_tree_process_radio_tree($element, $form_state) {
  #dsm($element, 'term_reference_tree_process_radio_tree');
  $element = _term_reference_tree_render($element, $form_state);
  return $element;
}

/**
 * Returns HTML for a checkbox_tree form element.
 *
 * @param $variables
 *   An associative array containing:
 *   - element: An associative array containing the properties of the element.
 *
 * @ingroup themeable
 */
function theme_checkbox_tree($variables) {
  # Lifted from theme_checkboxes in form.inc for now
  //dsm($variables, 'theme_checkbox_tree');
  $element = $variables['element'];
  
  # TODO: In the checkboxes widget, for some reason the children get there
  # already rendered.  Why is this?
  $element['#children'] = drupal_render_children($element);
  
  $attributes = array();
  if (isset($element['#id'])) {
    $attributes['id'] = $element['#id'];
  }
  $attributes['class'][] = 'form-checkboxes';
  
  if(form_get_error($element)) {
		$attributes['class'][] = 'error';
	}
	
	if(!empty($element['#required'])) {
		$attributes['class'][] = 'required';
	}
	
  if (!empty($element['#attributes']['class'])) {
    $attributes['class'] = array_merge($attributes['class'], $element['#attributes']['class']);
  }
  return '<div' . drupal_attributes($attributes) . '>' . (!empty($element['#children']) ? $element['#children'] : '') . '</div>';
}

/**
 * Returns HTML for a radio_tree form element.
 *
 * @param $variables
 *   An associative array containing:
 *   - element: An associative array containing the properties of the element.
 *
 * @ingroup themeable
 */
function theme_radio_tree($variables) {
  #$element = $variables['element'];
  #dsm($variables, 'theme_radio_tree');
  return theme_checkbox_tree($variables);
}

/**
 * Implements hook_widget_field_form().
 */
function term_reference_tree_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  #dsm(func_get_args(), 'term_reference_tree_field_widget_form args');
  $voc = taxonomy_vocabulary_machine_name_load($field['settings']['allowed_values'][0]['vocabulary']);
  $terms = taxonomy_get_tree($voc->vid, $field['settings']['allowed_values'][0]['parent']);
  $path = drupal_get_path('module', 'term_reference_tree');
  $value_key = key($field['columns']);
  
  $required = $element['#required'];
  if($field['cardinality'] == 1 && !$required) {
    array_unshift($terms, (object) array(
      'tid' => '',
      'name' => 'N/A',
      'depth' => 0
      )
    );
  }

  $type = $instance['widget']['type'];
  $multiple = $field['cardinality'] > 1 || $field['cardinality'] == FIELD_CARDINALITY_UNLIMITED;  
  $has_value = isset($items[0][$value_key]);
  #$properties = _options_properties($type, $multiple, $required, $has_value);
  $properties = array();
  $options = _term_reference_tree_get_options($terms);
  $settings = $instance['widget']['settings'];
  
  #dsm($items, 'term_reference_tree_field_widget_form items');
  #dsm($options, 'term_reference_tree_field_widget_form options');
  
  $default_value = array();
  foreach($items as $item) {
    $key = $item[$value_key];
    if(isset($options[$key])) {
      if($key === 0) 
        $default_value[$key] = '0';
      else
        $default_value[$key] = $key;
    }
  }
  
  if(!array_key_exists('#value', $element))
    $element['#value'] = array();

  # A switch statement, in case we ever add more widgets to this module
  switch($instance['widget']['type']) {
    case 'term_reference_tree':
			$element['#attached']['js'] = array($path . '/term_reference_tree.js');
			$element['#attached']['css'] = array($path . '/term_reference_tree.css');
      #drupal_add_js($path . '/term_reference_tree.js', 'file');
      #drupal_add_css($path . '/term_reference_tree.css', 'file');
      $element['#type'] = $multiple ? 'checkbox_tree' : 'radio_tree';      
      $element['#options'] = $options;
      $element['#options_tree'] = $terms;
      $element['#default_value'] = $multiple ? $default_value : array(reset($default_value) => reset($default_value));
      $element['#max_choices'] = $field['cardinality'];
      $element['#start_minimized'] = $settings['start_minimized'];
      $element['#leaves_only'] = $settings['leaves_only'];

      $value = (is_array($element['#value'])) ? $element['#value'] : array();
      break;
  }
  
  $element += array(
    '#value_key' => $value_key,
    '#element_validate' => array('_term_reference_tree_widget_validate'),
    #'#value_callback' => 'form_type_checkboxes_value',
    '#properties' => $properties,
  );
  
  #dsm($element, 'term_reference_tree_field_widget_form');
  return $element;
}

/*
function term_reference_tree_process_term_reference_tree($element) {
  #dsm($element, 'term_reference_tree_process_term_reference_tree');
  return $element;
}
*/

/**
 * Validates the term reference tree widgets.
 * 
 * This function sets the value of the tree widgets into a form that Drupal
 * can understand, and also checks if the field is required and has been
 * left empty.
 * 
 * @param $element
 *   The element to be validated.
 * @param $form_state
 *   The state of the form.
 * 
 * @return
 *   The validated element.
 */
function _term_reference_tree_widget_validate(&$element, &$form_state) {
  #dsm($element, '_term_reference_tree_widget_validate');
  $children = element_children($element);
  $value = array();
  
  if($element['#type'] == 'checkbox_tree') {    
    foreach($children as $c) {
      $child = $element[$c];
      if(array_key_exists('#value', $child) && $child['#value'] !== 0) {
        array_push($value, array($element['#value_key'] => $child['#value']));
      } 
    }
  } else {
    # If it's a tree of radio buttons, they all have the same value, so we can just
    # grab the value of the first one.
    if(is_array($children) && count($children) > 0) {
      $child = $element[reset($children)];
      if(array_key_exists('#value', $child) && $child['#value'] !== 0) {
        array_push($value, array($element['#value_key'] => $child['#value']));
      }       
    }
  }
  
	if ($element['#required'] && count($value) == 0) {
    form_error($element, t('!name field is required.', array('!name' => $element['#title'])));
  }
  
  form_set_value($element, $value, $form_state);
  #dsm($value, '_term_reference_tree_widget_validate value');
  #dsm($form_state, '_term_reference_tree_widget_validate form_state');
  return $element;
}

/*
function _term_reference_tree_form_value($in) {
  $out = array();
  foreach($in as $val) {
  }
}
*/

/**
 * Return an array of options.
 * 
 * This function converts a list of taxonomy terms to a key/value list of options.
 * 
 * @param $terms
 *   An array of taxonomy term IDs.
 * 
 * @return
 *   A key/value array of taxonomy terms (name => id)
 */
function _term_reference_tree_get_options($terms) {
  $options = array();
  
  if(is_array($terms) && count($terms) > 0) {
    foreach($terms as $term) {
      $options[$term->tid] = $term->name;
    }
  }
  return $options;
}

/**
 * Render the term reference tree element.
 * 
 * This function renders the term reference tree element to its #markup
 * parameter.
 * 
 * @param $element
 *   The element to be rendered.
 * @param $form_state
 *   The form state.
 * 
 * @return
 *   The rendered element.
 */
function _term_reference_tree_render($element, $form_state) {
  #dsm($element, '_term_reference_tree_render');
  #dsm($form_state, '_term_ref form state');
  
  
  $value = !empty($element['#default_value']) ? $element['#default_value'] : array();
  $terms = !empty($element['#options_tree']) ? $element['#options_tree'] : array();
  $max_choices = !empty($element['#max_choices']) ? $element['#max_choices'] : 1; 
  
  if($max_choices != 1)
    $element['#tree'] = TRUE;
   
  # TODO: Use javascript to count how many are selected.
 
  $prev_depth = -1;
  $first_element = true;
  $last_element = false;
   
  while(count($terms) > 0) {
    $has_children = false;
    $term = array_shift($terms);
    
    # Get a copy of the next term
    $next_depth = -1;
    if(count($terms) > 0) {
      $next_term = reset($terms);
      $next_depth = $next_term->depth;
    } else {
      $last_element = true;
    }
    
    if(!$last_element && $next_depth > $term->depth) $has_children = true;
    
		//dsm("{$term->name} depth: " . $term->depth . " -> $next_depth" . ($has_children ? "(+)" : ""));
		
    $key = $term->tid;
    if ($key === 0) {
      $key = '0';
    }
    
    $element += array($key => array());
    
    if(!$element['#leaves_only'] || !$has_children) {
      $e = array(
        '#type' => ($max_choices == 1) ? 'radio' : 'checkbox',
        '#title' => $term->name,
        '#return_value' => $key,
        '#default_value' => isset($value[$key]) ? $key : NULL,
        '#attributes' => isset($element['#attributes']) ? $element['#attributes'] : NULL,
        '#ajax' => isset($element['#ajax']) ? $element['#ajax'] : NULL,
      );
      
      #dsm($e['#type'], 'element type');
      if($e['#type'] == 'radio') {
        $parents_for_id = array_merge($element['#parents'], array($key));
        $e['#id'] = drupal_html_id('edit-' . implode('-', $parents_for_id));
        $e['#parents'] = $element['#parents'];
        #dsm($parents_for_id, "PARENTS");
      }
    } else {
      $e = array(
        '#markup' => "<div class='parent-term'>{$term->name}</div>",
      );
    }
    
    if($first_element) {
			$sm = '';
			if($element['#start_minimized']) {
				$sm = " term-reference-tree-start-minimized";
			}
			
      $e['#prefix'] = "<ul class='term-reference-tree$sm' data-max-choices='$max_choices'><li data-depth='{$term->depth}'>";
			
			if($has_children) {
				$e['#prefix'] .= "<div class='term-reference-tree-button'></div>";
			} else {
				$e['#prefix'] .= "<div class='no-term-reference-tree-button'></div>";
			}
    } else {
      $expand_class = '';
      if($has_children && $element['#leaves_only'])
        $expand_class = " class='expandbutton'";
        
      if($term->depth > $prev_depth) {
        $e['#prefix'] = "<ul><li data-depth='{$term->depth}'$expand_class>";
      } elseif($term->depth < $prev_depth) {
        $e['#prefix'] = "<li data-depth='{$term->depth}'$expand_class>";
      } else {
        $e['#prefix'] = "<li data-depth='{$term->depth}'$expand_class>";
      }
      
      if($has_children) {
        $e['#prefix'] .= "<div class='term-reference-tree-button'></div>";
      } else {
        $e['#prefix'] .= "<div class='no-term-reference-tree-button'></div>";
      }
    }
    
    if($last_element) {
      $e['#suffix'] = "</li></ul>";
    } else {
      if($term->depth > $next_depth) {
        $e['#suffix'] = "</li></ul></li>";
      } elseif($term->depth < $next_depth) {
        $e['#suffix'] = "";
      } else {
        $e['#suffix'] = "</li>";
      }
    }
    
    $element[$key] += $e;
    $prev_depth = $term->depth;
    $first_element = false;
  }
  #dsm($element, '_term_reference_tree_render finished');
  return $element;
}

